# Reflection

## Vy

One of the most significant benefits of working as a team was the exposure to different perspectives on the course material. We each interpreted concepts like Concepts and Syncs slightly differently. By comparing our ideas and debating different implementations, I was able to deepen my understanding on these concepts. For example, when we were designing our concepts, we debated whether to combine or separate certain concepts and certain actions violated the "modularity" rule of concepts.

Another aspect that made working as a team interesting was the use of AI tools. Using these tools on a team project introduced a new layer of complexity. Tools like Gemini LLM and Cursor helped accelerate our individual tasks, but they also created new challenges around code consistency and merge conflicts that required careful management.

Different AI tools and different prompting styles led to variations in code structure and formatting. For example, when we split up the implementation for the backend concepts and worked on them in parallel, we found that the structures were vastly different. When we met for our team meeting, we realized that we should all use the same prompts and tools to ensure consistency.

On the frontend, we took a different approach. Since Cursor was especially prone to generating code that diverged from the rest of our structure, we leaned heavily on pair programming. Meeting in person allowed us to guide the tool together, review changes as they happened, and keep everyone aligned on style and architecture. This not only reduced inconsistencies but also helped us learn from each otherâ€™s coding habits and troubleshooting strategies in real time.

## Jocelyn

I learned that it's really important to start coding with a well fleshed out plan. Completely understanding what would be on the frontend before implementing queries on the backend would've helped us in not having to create queries later on based on missing functionality. We ended up having to modify our concept implementations a bit to support functionality we wanted on the frontend like being able to assign book covers to recipe books and allowing users to delete and edit names. I also learned how important it is to be guided by your problem statement to limit scope creep and make more informed choices when choosing functionality to trade off when you have limited time to implement your app.

Working in a group made the work much more manageable, but it would've been much easier to handle if we were able to do frontend tasks in parallel more. A large part of our implementation process also involved testing and catching bugs on the deployed website, and then fixing them on the frontend. This was a long and tedious process since we couldn't really fix things in parallel, because issues were oftentimes linked to one another, or fixing one thing could mess up another (the issues being things like page formatting, things on the backend that didn't work as expected, etc.). We were able to initially implement and test our backend concepts very quickly though, because we worked in parallel. Having multiple opinions and people to ask when you have a question about how a concept should be structured or what features to prioritize/trade off made decision making much easier and faster. I learned that it was very very important to have in-person synchronous meetings, because they made it easier to stay focused but also allows you to get immediate feedback. When we tried to make decisions over text, they took much longer and issues were often left unresolved until we had our weekly in-person meeting. Overall, I much preferred working in a group than working alone.

## Paul
